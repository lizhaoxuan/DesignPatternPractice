##一句话设计模式

如果有面试官问：你知道6大原则是哪6大吗？你应该能一一列举出来。又问：你能说出23种设计模式吗？你有点艰难了。再问：列出每种设计模式，并说出他们的概念，你要奔溃了……

模式很多，书很厚，不能每次都翻书，我需要精简的总结一下.

=================

###单一职责原则

无论比变量、方法、类、接口等等，他们的职责或代表的含义负责的功能都应该是单一独立的，一个模块不能负责超过两种事情，一种事情也尽量不要在多个地方都进行实现。


###里氏替换原则

凡是父类、接口可以出现的地方，其子类、实现类都可以无缝替换


###依赖倒置原则

模块之间的依赖应该通过抽发生（接口、超类），而不是具体的实现类。


###接口隔离原则

客户端不应该依赖它不需要的接口，类与类之间的依赖也应该建立在最小的接口上。

###迪米特法则

一个对象要对其他对象有最少的了解，只知道自己必须要知道的，只关心自己直接依赖的。


###开闭原则

在中后期开发中，在功能的扩展与修改上。最小程度的对源代码进行修改，通过增加代码实现扩展。

====================

###单例

通过私有化构造函数、本类静态成员对象从而保证在该系统中此类只有一个实例。



###工厂方法

#### - 普通工厂

定义一个创建对象的接口，由其子类决定如何实现。并交给客户端决定创建哪类对象。

#### - 简单工厂

不需要多个工厂类的情况下，将工厂类方法变为静态方法。

#### - 抽象工厂

负责生产一组相关或相互依赖的产品族的工厂。


###模板方法

父类负责定义“算法”的框架，子类负责算法的具体实现。

将不变的共同的封装进父类中，变化的由各子类实现


###建造者模式

将对象的“组装”“创建”过程进行封装。使得不同封装过程有着不同的表示结果。

（而更多的实践中，我们更倾向于依照不同零件的载入，给予不同的创建结果）

###代理模式

委托的一种。为其他对象提供一个代理对象，控制对这个对象的访问。**代理模式更倾向于对过程的控制。**



###原型模式

在原有实例的基础上，通过clone关键字拷贝原有实例，创建新的对象。
（但要注意深拷贝和浅拷贝的问题）


###中介者模式

用中介对象封装一系列对象之间的交互，使得各对象之间不需要显示的交互，使耦合松散。而且可以独立改变他们之间的交互。


###命令模式

将一个请求及请求实现的过程和依赖的类封装成一个对象，客户端只需要调用该请求即可。


###责任链模式

将多个处理请求的对象按照优先级连成一条链，并沿着该条链处理请求，使得多个对象都有机会处理。

###装饰模式

委托的一种。动态的为其他对象添加额外的功能。**装饰模式更倾向于对功能的扩展**

###策略模式

委托的一种。定义一组算法，将每一种算法封装起来，并且他们之间可以互换。**策略模式更倾向于替换**

###适配器模式

将一个类转换为另一个类，使得原本不能直接依赖的类变得可以依赖。

###迭代器模式

提供一种方法访问一个容器各个元素，而又不暴露该对象的内部细节。


###组合模式

一个树形结构的对象组合关系，将单个对象和组合对象的共同部分抽象。使得在使用中具有一致性。

###观察者模式

利用回调方法，建立对象之间一对多的依赖关系。使得被观察对象在状态改变时，其他观察对象都可以得到通知。

###门面模式

对一个子系统进行包装，子系统与外部系统之间的交互必须通过该门面对象进行。使得子系统更易于使用与替换。

###备忘录模式

保存一个对象的状态，在需要时将该对象恢复到原先保存的状态下。

###访问者模式

将对象的“展示”封住到访问类中，将数据的和其展示解耦。其实现类似回调机制。

###状态模式

以状态为类型，封装对象因为状态改变而引起的行为变化。

###解释器模式（暂不熟）

###享元模式

就是对象池机制（模式）

###桥梁模式

将抽象与现实分离。使两者可以独立改变而不影响对方。







